#include "./lodash.jsxinc"

var l0 = {
        getPaths : function(container, pathItemTypes, pathProps, containerProps, layerProps, matchPathProps, matchContainerProps, matchLayerProps)
        {       
            // Defaults:
            matchPathProps = this.setDefault(matchPathProps, true)
            matchContainerProps = this.setDefault(matchContainerProps, true)
            matchLayerProps = this.setDefault(matchLayerProps, true)
            pathItemTypes = this.setDefault(pathItemTypes,  ["PathItem"])
           
            var isSelection = container.length >= 0
            var allPaths = []
            var containerTypes = ["GroupItem", "Layer"] // coming across a layer shouldn't happen, but it's adobe, who knows?
            if (_.indexOf(pathItemTypes, "CompoundPathItem") == -1) { containerTypes.push("CompoundPathItem") }
            
            getPaths_process(container, 0)
            return allPaths
            
            function getPaths_process(container, depth)
            {
                if((l0.hasProps(container, containerProps) == matchContainerProps) ) {
                    var pIs = isSelection && depth == 0 ? container : (container.typename == "CompoundPathItem" ? container.pathItems : container.pageItems)                                      
                    _.chain(pIs).filter(function(pI) {
                            var isLevelNItem = l0.isLevel0PageItem(pI) || container == l0.getParentEx(pI) // make sure all pageItems are direct children of the parent
                            return (isLevelNItem || (isSelection && depth == 0)) && l0.hasProps(pI.layer, layerProps)  == matchLayerProps
                    }).forEach(function(pI) 
                    {
                        if(_.contains(pathItemTypes, pI.typename) &&  l0.hasProps(pI, pathProps)  == matchPathProps) {
                            allPaths.push(pI)
                        }
                        else if(_.contains(containerTypes, pI.typename)) {
                            // handle cases where compound paths contain groups, hiding the paths contained within
                            if(pI.typename == "CompoundPathItem" && pI.pathItems.length == 0 && !_.contains(pathItemTypes, pI.typename)) {
                                _.chain(doc.pageItems).where({'parent': pI}).forEach(function(cpiChild) {
                                    cpiChild.typename == "PathItem" && l0.hasProps(cpiChild, pathProps) == matchLayerProps ? allPaths.push(cpiChild) 
                                                                                                                                                                            :  getPaths_process (cpiChild, depth+1)
                                })
                            }
                            else getPaths_process(pI, depth+1)
                        }
                    })
                }
                depth--
            }
        }, 
        hasProps : function(object, props)
        {
            return !props || ( object && _.where([object], props).length > 0)
        },
        getParentEx : function(object) {
            if(object.typename == "PathItem")
            {
                    var cmpPath = _.find(object.parent.compoundPathItems, function(cmp) {
                        return _.indexOf(cmp.pathItems,object)>= 0;
                    })
            }
            return cmpPath ? cmpPath : object.parent
        }, 
        isLevel0PageItem : function(pageItem)
        {
            var parent = pageItem.parent
            return parent.typename == "Layer" && parent.parent.typename == "Document"
        },
        setDefault : function(v, def)
        {
            return typeof v !== 'undefined' ? v : def
        },
        movePathsToCompound : function(container, cmpnd)
        {
               while(container.pathItems.length > 0) {
                    container.pathItems[0].move(cmpnd, ElementPlacement.PLACEATEND)
               } 
               if(container.compoundPathItems) {
                    while(container.compoundPathItems.length > 0) { 
                         l0.movePathsToCompound(container.compoundPathItems[0], cmpnd)
                          container.compoundPathItems[0].remove()
                    }
               }
         },
        genNewGUID: function(obj)
        {
            // http://stackoverflow.com/a/2117523
            obj.note = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
                return v.toString(16);
             })
            return obj.note
        },
        genGUIDs: function(obj, containerOnly)
        {
            obj = this.setDefault(obj,  app.activeDocument)
            objs = containerOnly  || !obj.pageItems ? [obj] : [obj].concat(_.toArray(obj.pageItems))
            _.chain(objs).filter(function(pI) { return !pI.guid }).forEach(function(pI) { this.genNewGUID(pI) },this)
       },
       getGUID: function(obj)
       {
          mPos = obj.note.search(/[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}/i)
          return mPos >= 0 ? obj.note.substr(mPos, 36) : this.genNewGUID(obj)
       },
       reorderPageItem: function(pageItem, count) 
       {
            for(var i=0; i<Math.abs(count); i++) {
                count < 0 ? pageItem.zOrder(ZOrderMethod.BRINGFORWARD) : pageItem.zOrder(ZOrderMethod.SENDBACKWARD)
            }
        }
}